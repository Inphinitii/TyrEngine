#include "XWindow.h"

#include <iostream>

AbstractWindow* AbstractWindow::m_window;

/**
 * \brief 		Create a new X Window with information supplied by the WindowConfig structure.
 * \param 	_conf WindowConfig*
 * \return  	bool
 */
bool XWindow::CreateWindow(WindowConfig &_conf)
{
    //Copy the configuration internally and set the window type. LINUX == 1
    //Change this later: Set an OS preprocessor to a string LINUX, WINDOWS, etc.
    //Compare the string to set up the render accordingly.

    m_configuration = _conf;
    m_configuration.windowType = 1;
    XInitThreads();

    //Default Values
    m_display               	= XOpenDisplay(NULL);                  		 					//Open an empty X11 Display
    m_screen                	= DefaultScreen(m_display);             					//Obtain the default screen
    m_rootWindow    	= RootWindow(m_display, m_screen);      		//Obtain the X11 Root Window
    m_colorMap 			= DefaultColormap(m_display, m_screen); 	//Obtain the appropriate color map.

    if(m_rootWindow != 0)
    {
        //Create a simple X Window.
        m_currentWindow = XCreateSimpleWindow(m_display,													//Current display
																										m_rootWindow,                     						//Root Window
																										m_configuration.x,               					//Window X Position
																										m_configuration.y,              						//Window Y Position
									    static_cast<unsigned int>(m_configuration.width),						//Window Width
										static_cast<unsigned int>(m_configuration.height), 						//Window Height
																										0,                                										//Border Size
																										WhitePixel(m_display,m_screen), 	//Border Color
																										WhitePixel(m_display,m_screen));	//Background Color

        if(m_currentWindow)
        {
            //Create a graphical context and associate it with the current window
            m_graphicContext= XCreateGC(m_display, m_currentWindow, 0, NULL);

            //Store the name of the window
            XStoreName(m_display, m_currentWindow, m_configuration.windowName);

            //Set the foreground color of the display
            XSetForeground(m_display, m_graphicContext, m_currentWindow);

            //Mask that determines what events will be handled by our application
            m_eventMask = ExposureMask |
                                                KeyPressMask |
                                                KeyReleaseMask |
                                                PointerMotionMask |
                                                ButtonPressMask |
                                                ButtonReleaseMask;

            XSelectInput(m_display, m_currentWindow, m_eventMask );

            //Map the window to the X11 Windowing System
            XMapWindow(m_display, m_currentWindow);

            //Log Manager: X11 Window created successfully

            return true;
        }
        else
        {
            //Log Manager: Failed to create an X11 Session
            return false;
        }
    }
    else
    {
        //Log Manager: Failed to obtain the root X11 Window
        return false;
    }
}

/**
 * \brief 		Reset the current X Window with information supplied by the WindowConfig structure.
 * \param 	_conf WindowConfig*
 * \return  	bool
 */
bool XWindow::ResetWindow(WindowConfig &_conf)
{
    m_changes.x = _conf.x;
    m_changes.y = _conf.y;
    m_changes.width = _conf.width;
    m_changes.height = _conf.height;

    //XConfigureWindow(m_display, m_currentWindow)

    return true;
}

/**
 * \brief 		Resize the current X Window
 * \param 	_x int
 * \param  	_y int
 * \return  	bool
 */
bool XWindow::ResizeWindow(unsigned int _x, unsigned int _y)
{
    XResizeWindow(m_display, m_currentWindow, _x, _y);
    return true;
}

/**
 * \brief 		Render a connected graphical context to the X Window.
 */
void XWindow::Render()
{
   // std::cout << "Updating! " << std::endl;
}

/**
 * \brief 		Receive and process events generated by the X Window
 */
void XWindow::HandleEvents()
{
        //NEED TO WRITE A CROSS-OS EVENT HANDLER
        //XWarpPointer() // Move Mouse

        //Non-Blocking Event Handling
        if(XCheckWindowEvent(m_display, m_currentWindow, m_eventMask, &m_event ))
        {
            if(m_event.type == KeyPress)
            {
                std::cout << "Ding" << std::endl;
            }
        }

}

void XWindow::Update(float _time)
{
    while(1)
    {
        HandleEvents();
        Render();
    }

}

XWindow::XWindow()
{
}

XWindow::~XWindow()
{
    XCloseDisplay(m_display);
}

